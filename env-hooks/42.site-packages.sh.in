#!/usr/bin/env bash
# generated from catkin_pip/env-hooks/42.site-packages.sh.in

# For catkin it is simpler to do that in _setup_util.py.in.
# but until catkin does this by default the proper way from outside catkin is probably a env-hook

##Documentation:
#  The colon command simply has its arguments evaluated and then succeeds.
#  It is the original shell comment notation (before '#' to end of line). For a long time, Bourne shell scripts had a colon as the first character.
#  The C Shell would read a script and use the first character to determine whether it was for the C Shell (a '#' hash) or the Bourne shell (a ':' colon).
#  Then the kernel got in on the act and added support for '#!/path/to/program' and the Bourne shell got '#' comments, and the colon convention went by the wayside.
#  But if you come across a script that starts with a colon (Like this one), now you will know why. ~ Jonathan Leffler

: ${CATKIN_PIP_ENV_HOOKS_DIR:="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"}
: ${CATKIN_PIP_CURRENT_WORKSPACE:="$( dirname "$( dirname "$(dirname "${CATKIN_PIP_ENV_HOOKS_DIR}" )" )" )"}

# We should enable site-package only on devel space.
# Install space should behave like packages, everything in debian layout.
if [ "@DEVELSPACE@" == "True" ]; then

    # finding our useful script from catkin_pip using rospack (work from source or bin package)
    CATKIN_PIP_SCRIPTS=$(rospack find catkin_pip)/scripts
    echo "Catkin-pip scripts found in $CATKIN_PIP_SCRIPTS"

    # we combine it with site-packages (pip default) location, before attempting to prepend to the python path
    echo "Prepending ${CATKIN_PIP_CURRENT_WORKSPACE}/lib/python2.7/site-packages to PYTHONPATH"
    $CATKIN_PIP_SCRIPTS/pythonpath_prepend.bash "${CATKIN_PIP_CURRENT_WORKSPACE}/lib/python2.7/site-packages"
fi